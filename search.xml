<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>博客回归</title>
      <link href="/2020/07/01/bo-ke-hui-gui/"/>
      <url>/2020/07/01/bo-ke-hui-gui/</url>
      
        <content type="html"><![CDATA[<p>2020.07.08博客回归，写一些学到的数学、英语、和数据结构的知识（包含C）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>软件测试执行管理</title>
      <link href="/2019/08/27/ruan-jian-ce-shi-zhi-xing-guan-li/"/>
      <url>/2019/08/27/ruan-jian-ce-shi-zhi-xing-guan-li/</url>
      
        <content type="html"><![CDATA[<h2 id="测试执行过程"><a href="#测试执行过程" class="headerlink" title="测试执行过程"></a>测试执行过程</h2><p><img src="/image/2019-08-27-07-34-32.jpg" alt></p><h2 id="测试执行的主要任务"><a href="#测试执行的主要任务" class="headerlink" title="测试执行的主要任务"></a>测试执行的主要任务</h2><ol><li>确定测试用例的优先级</li><li>创建测试数据、测试工具、自动化测试脚本</li><li>根据测试规程创建测试套件、以提高测试执行的效率</li><li>确认已正确搭建了测试环境</li><li>执行测试规程</li><li>记录测试结果、被测软件、测试工具、测试件的标识和版本</li><li>实际结果与预期结果比较</li><li>如果有差异，作为事件上报</li><li>缺陷修正后，重新执行测试活动</li></ol><h2 id="测试准入准出标准"><a href="#测试准入准出标准" class="headerlink" title="测试准入准出标准"></a>测试准入准出标准</h2><ol><li>编码结束，完成单元测试</li><li>确定测试范围</li><li>完成集成测试、基本流程走通、符合软件编码规范</li><li>开发提交最新版本代码、提交并通知测试组进行测试</li><li>兼容性测试要求明确</li><li>安全测试和性能测试范围和要求</li></ol><h2 id="测试暂停、停止"><a href="#测试暂停、停止" class="headerlink" title="测试暂停、停止"></a>测试暂停、停止</h2><ol><li>测试人员先进行冒烟测试、测试无法正常进行、测试暂停并返回开发</li><li>被侧项目需调整而暂停</li><li>存在其他优先级更高的任务、向领导申请暂停测试</li><li>被测系统经过系统测试、达到系统准出标准、可以停止测试</li></ol><h2 id="测试准出标准"><a href="#测试准出标准" class="headerlink" title="测试准出标准"></a>测试准出标准</h2><ol><li>被测项目满足需求原型的要求</li><li>所有测试用例都已经通过评审</li><li>所有测试用例已成功执行</li><li>测试覆盖率是否达到100%</li><li>所有发现的缺陷都记录在缺陷管理系统</li><li>一二级错误修复率达到100%  (严重的错误、优先级比较高的)</li><li>三四次错误修复率达到95% </li><li>所有遗留问题都已有解决方案</li><li>性能指标是否达到要求</li><li>兼容性测试是否满足</li><li>安全测试是否达到要求</li><li>产出系统测试总结报告</li></ol><h2 id="软件缺陷"><a href="#软件缺陷" class="headerlink" title="软件缺陷"></a>软件缺陷</h2><p>缺陷是一种泛称、它可以指功能测试、也可以指性能低下、易用性差等<br>并不是所有测试人员都能提交被开发认可的缺陷、也不是测试人员任何时候都能提交被开发认可的缺陷</p><ol><li>软件未达到产品说明书标明的功能</li><li>软件出现了产品说明书指明不会出现的错误</li><li>软件功能超出了产品说明书指明范围</li><li>软件未达到产品说明书未指出但应达到的目标</li><li>软件测试发现难以理解、不易使用、运行速度缓慢、或者最终用户认为不好</li></ol><h2 id="缺陷产生的原因"><a href="#缺陷产生的原因" class="headerlink" title="缺陷产生的原因"></a>缺陷产生的原因</h2><p><img src="/image/2019-08-27-07-59-59.jpg" alt></p><h2 id="发现缺陷"><a href="#发现缺陷" class="headerlink" title="发现缺陷"></a>发现缺陷</h2><ol><li>用户体验不好</li><li>界面上有些明显的错误信息</li><li>功能不完备，没有按照需求说明编写代码， 致使某些功能缺失</li><li>功能不完善，不能正常运行或者运行的过程中出现程序崩溃，停止运行的错误</li><li>逻辑不正确，与需求说明书、测试用例不符</li><li>模块之间的交互性不好、与其他模块做集成测试遇到问题</li><li>程序性能不够好，不能承载压力考验</li></ol><h2 id="缺陷报告"><a href="#缺陷报告" class="headerlink" title="缺陷报告"></a>缺陷报告</h2><h3 id="BUG重现"><a href="#BUG重现" class="headerlink" title="BUG重现"></a>BUG重现</h3><ol><li>做好记录</li><li>查找时间依赖和竞争条件的问题(时间、环境条件)</li><li>边界条件软件缺陷、内存泄漏和数据溢出等白盒问题都可能会慢慢自己显露出来</li><li>状态缺陷仅在特定软件状态中先露出来</li><li>考虑资源依赖性和内存问题<h3 id="无法重现的BUG"><a href="#无法重现的BUG" class="headerlink" title="无法重现的BUG"></a>无法重现的BUG</h3></li><li>应当对这样的缺陷进行详细的记录，并尽快提交给开发人员</li><li>对于寻找难以再现的缺陷要合理地安排时间，暂时搁置</li><li>最后在测试过程中</li></ol><p>书写良好的软件缺陷报告，提供给开发人员、质量管理人员 </p><h3 id="缺陷报告写作标准"><a href="#缺陷报告写作标准" class="headerlink" title="缺陷报告写作标准"></a>缺陷报告写作标准</h3><ol><li>准确</li><li>清晰</li><li>简洁: 只包含必不可少的信息、不包含任何多余的内容</li><li>完整:</li><li>一致</li></ol><h2 id="缺陷报告的组织架构"><a href="#缺陷报告的组织架构" class="headerlink" title="缺陷报告的组织架构"></a>缺陷报告的组织架构</h2><ol><li>缺陷的标题(使用关键字)</li><li>缺陷的基本信息: 环境信息、版本信息</li><li>测试的软件和硬件环境</li><li>测试的软件版本</li><li>缺陷类型</li><li>缺陷的严重程度(缺陷级别)</li><li>缺陷的处理优先级</li><li>复现缺陷的操作步骤</li><li>缺陷的实际结果描述</li><li>缺陷的正确结果描述</li><li>注释文字和截取的缺陷图形</li></ol><h2 id="缺陷报告注意事项"><a href="#缺陷报告注意事项" class="headerlink" title="缺陷报告注意事项"></a>缺陷报告注意事项</h2><ol><li>BUG归类</li><li>读者是否容易搜索该BUG</li><li>缺陷描述是否清除(环境变量、数据文件、是否容易引起歧义)</li></ol><h2 id="缺陷报告原则"><a href="#缺陷报告原则" class="headerlink" title="缺陷报告原则"></a>缺陷报告原则</h2><ol><li>组织</li><li>重现</li><li>隔离(试着隔离错误，找到问题地原因)</li><li>归纳</li><li>对比: (如回归测试中测试用例输出结果不一样)</li><li>总结</li><li>精简</li><li>消除歧义</li><li>中立</li><li>检查</li></ol><h2 id="缺陷跟踪"><a href="#缺陷跟踪" class="headerlink" title="缺陷跟踪"></a>缺陷跟踪</h2><p><img src="/image/2019-08-27-08-51-20.jpg" alt></p><h2 id="缺陷跟踪管理系统"><a href="#缺陷跟踪管理系统" class="headerlink" title="缺陷跟踪管理系统"></a>缺陷跟踪管理系统</h2><p>JIRA、 BUGZILLA、 QC、 禅道</p><h2 id="禅道"><a href="#禅道" class="headerlink" title="禅道"></a>禅道</h2><p>基于敏捷思想的项目管理软件</p><h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><ol><li>产品经理创建产品</li><li>产品经理创建需求</li><li>项目经理创建项目</li><li>项目经理确定项目要做的需求</li><li>项目经理分解任务，指派相应的人员</li><li>测试人员提交bug</li></ol><h2 id="易用性测试"><a href="#易用性测试" class="headerlink" title="易用性测试"></a>易用性测试</h2><ol><li>用户点击鼠标三次就可以达到用户的目的</li><li>易用性和可用性存在一定的区别，可用性是指是否可以使用、而易用性是指是否方便使用</li></ol><h2 id="易用性测试的内容"><a href="#易用性测试的内容" class="headerlink" title="易用性测试的内容"></a>易用性测试的内容</h2><ol><li>易理解性</li><li>易学习性</li><li>易操作性</li><li>吸引性</li><li>依从性</li></ol><h2 id="易用性测试方法"><a href="#易用性测试方法" class="headerlink" title="易用性测试方法"></a>易用性测试方法</h2><ol><li>导航测试</li><li>图形测试: 图片、动画、字体风格、颜色搭配</li><li>整体界面测试: 浏览是否舒适、设计风格是否一致</li></ol><h2 id="兼容性测试"><a href="#兼容性测试" class="headerlink" title="兼容性测试"></a>兼容性测试</h2><p>CTS : 浏览器、硬件、操作系统、网络环境</p><h3 id="Web兼容性"><a href="#Web兼容性" class="headerlink" title="Web兼容性"></a>Web兼容性</h3><ol><li>浏览器兼容</li><li>屏幕尺寸，分辨率</li><li>操作系统</li></ol><h4 id="Web兼容性测试方法"><a href="#Web兼容性测试方法" class="headerlink" title="Web兼容性测试方法"></a>Web兼容性测试方法</h4><ol><li><p>根据内核分析 IE Chorme(webkit Blinke) FireFox 其他<br>Chrome: Webkit内核  Blink内核<br>FireFox: 最新版本<br>IE: 7-11<br>Safari: mac版本单独测试<br>Edge: window10<br>360安全浏览器(双核版)<br>搜狗等其他浏览器任选其一</p></li><li><p>BrowerShots<br>通过在线截图的方式展现页面得兼容性</p></li></ol><h2 id="APP兼容测试"><a href="#APP兼容测试" class="headerlink" title="APP兼容测试"></a>APP兼容测试</h2><ol><li>设备型号兼容测试</li></ol><h3 id="APP测试方法"><a href="#APP测试方法" class="headerlink" title="APP测试方法"></a>APP测试方法</h3><ol><li>人工测试</li><li>第三方测试工具: 在线云平台</li></ol><h3 id="兼容性测试作用"><a href="#兼容性测试作用" class="headerlink" title="兼容性测试作用"></a>兼容性测试作用</h3><ol><li>提高产品质量</li><li>尽可能达到平台无关性</li><li>尽可能保证软件存在的价值</li><li>使软件产品的市场更广阔</li></ol><h2 id="OFO功能测试"><a href="#OFO功能测试" class="headerlink" title="OFO功能测试"></a>OFO功能测试</h2><h3 id="测试策划"><a href="#测试策划" class="headerlink" title="测试策划"></a>测试策划</h3><ol><li>检查需求分析文档</li></ol><p><img src="/image/2019-08-27-10-05-46.jpg" alt></p><ol start="2"><li>测试方案<br>(1) 总体计划安排和负责人<br>(2) 测试方案: 测试重点， 测试范围，设计系统、联测方案、测试策略方法<br>联测方案、测试工具平台<br>(3) 环境搭建部署及数据准备<br>(4) 测试限制、测试风险点</li></ol><h3 id="用例设计"><a href="#用例设计" class="headerlink" title="用例设计"></a>用例设计</h3><p>分系统模块<br>测试编号、 测试用例 前置条件 操作 测试结果 备注</p>]]></content>
      
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络应用层</title>
      <link href="/2019/08/25/ji-suan-ji-wang-luo-ying-yong-ceng/"/>
      <url>/2019/08/25/ji-suan-ji-wang-luo-ying-yong-ceng/</url>
      
        <content type="html"><![CDATA[<h2 id="应用层概述"><a href="#应用层概述" class="headerlink" title="应用层概述"></a>应用层概述</h2><p>应用层是面向用户的一层<br>UDP: 多媒体信息分发 视频、语音、实时信息<br>TCP: 可靠信息传输 金融交易、可靠通讯、 消息队列<br>定义应用间通信的规则<br>应用进程的报文类型(请求报文、应答报文)<br>报文的语言、格式<br>应用进程发送数据的时机、规则</p><h2 id="DNS详解"><a href="#DNS详解" class="headerlink" title="DNS详解"></a>DNS详解</h2><p>DNS(Domain Name System:域名系统)<br>域名: 点、字母、和数字组成<br>点分割不同的域<br>域名可以分为顶级域、二级域、三级域<br>顶级域: 国家、通用</p><p><img src="/image/2019-08-25-16-35-26.jpg" alt></p><p><img src="/image/2019-08-25-16-37-13.jpg" alt></p><p>DNS服务 域名转化为IP</p><h2 id="DHCP协议-动态主机设置协议"><a href="#DHCP协议-动态主机设置协议" class="headerlink" title="DHCP协议  (动态主机设置协议)"></a>DHCP协议  (动态主机设置协议)</h2><p>即插即用联网<br>DHCP 分配一个临时IP，无需配置，即可上网<br>DHCP 有租期<br>DHCP使用过程<br>DHCP服务器默认端口: 67<br>主机使用UDP协议 广播DHCP发现报文<br>DHCP服务器发出DHCP提供报文<br>主机向DHCP服务器发出DHCP请求报文<br>DHCP服务器回应并提供IP地址<br>以上过程主要在局域网完成</p><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p>超文本传输协议<br>HTTP协议时可靠的数据传输协议<br>http(s)://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;<br>端口为80或443<br>Web服务器: 硬件部分、软件部分(Apache、Nginx)<br>接受客户端连接 -&gt; 接受请求报文 -&gt; 处理请求 -&gt; 访问Web资源 -&gt; 构造应答 -&gt; 发送应答<br>HTTP 请求方法 : GET POST DELETE UPDATA ..<br>GET: 获取指定服务端资源,提交数据<br>POST: 提交数据到服务端<br>DELETE: 删除指定的服务端资源<br>UPDATA: 更新指定的服务器资源<br>在地址栏指定资源</p><h3 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h3><p>请求方法 请求地址 HTTP版本<br>请求头<br>请求内容</p><p>应答报文<br>HTTP版本 状态码 状态解释<br>应答头<br>应答内容</p><h3 id="HTTP工作结构"><a href="#HTTP工作结构" class="headerlink" title="HTTP工作结构"></a>HTTP工作结构</h3><ol><li>Web缓存<br>存放热门数据 Redis (K-V数据库)</li><li>Web代理<br>工作在客户端和服务端之间<br><img src="./_image/2019-08-25-17-36-15.jpg" alt><br>正向代理、反向代理 Nginx HAProxy<br>正向代理: 代表客户端访问服务端<br>反向代理: 代表服务端返回数据给客户端</li><li>CDN(内容分发网络)<br>网站在某地建立CDN方便附近用户使用CDN</li><li>爬虫</li></ol><h3 id="HTTPS协议详解"><a href="#HTTPS协议详解" class="headerlink" title="HTTPS协议详解"></a>HTTPS协议详解</h3><p>HTTP是明文传输的<br>加密模型<br>对称加密 ，加密解密密钥一致<br>非对称密钥 拥有一定数学关系的一组密钥<br>私钥 私钥自己使用、不对外公开<br>公钥 公钥给大家使用、对外公开<br>数字证书: 可信任组织 颁发给 特定对象</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试设计</title>
      <link href="/2019/08/25/ruan-jian-ce-shi-she-ji/"/>
      <url>/2019/08/25/ruan-jian-ce-shi-she-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="测试用例设计"><a href="#测试用例设计" class="headerlink" title="测试用例设计"></a>测试用例设计</h2><ol><li>设计测试用例， 并确定优先级</li><li>确定测试条件和必要的测试数据</li><li>测试用例应该具有可重复性、可验证性、需求可追踪性</li><li></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试技术深化</title>
      <link href="/2019/08/25/ce-shi-ji-zhu-shen-hua/"/>
      <url>/2019/08/25/ce-shi-ji-zhu-shen-hua/</url>
      
        <content type="html"><![CDATA[<h2 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h2><h3 id="代码审查"><a href="#代码审查" class="headerlink" title="代码审查"></a>代码审查</h3><ol><li>业务逻辑审查</li><li>算法效率</li><li>代码风格</li><li>编码规则</li></ol><p>互查: 在相同模块或相近模块的编程人员之间互相检查对方的代码<br>走查: 集中讨论代码的过程</p><ol><li>Java最基本语句的使用</li><li>重载函数的审查</li><li>内存管理</li><li>程序性能的审查<br>减少创建对象<br>减少循环体的执行代码、能放到循环体外的代码要尽量放在循环体外<br>提高处理异常出错的效率<br>减少I/O操作时间 </li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试流程</title>
      <link href="/2019/08/25/ruan-jian-ce-shi-liu-cheng/"/>
      <url>/2019/08/25/ruan-jian-ce-shi-liu-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="搭建测试环境"><a href="#搭建测试环境" class="headerlink" title="搭建测试环境"></a>搭建测试环境</h2><h3 id="搭建测试环境前"><a href="#搭建测试环境前" class="headerlink" title="搭建测试环境前"></a>搭建测试环境前</h3><ol><li>确认测试目的<br>功能测试: 不需要大量数据，需要覆盖率高，测试数据要求尽量真实<br>性能测试: 大量存量数据或者与硬件环境尽可能相似的硬件配置</li><li>测试的软件环境尽可能模拟真实环境</li><li>了解符合测试软件运行的最低要求及用户使用的硬件配置</li><li>产品化的测试需要考虑兼容性方案</li><li>营造独立的测试环境</li><li>构建可复用的测试环境: 构建可复用的测试环境</li></ol><h3 id="搭建环境过程分析"><a href="#搭建环境过程分析" class="headerlink" title="搭建环境过程分析"></a>搭建环境过程分析</h3><ol><li>线下搭建</li><li>独立测试服务器或虚拟机</li><li>测试环境配置</li><li>测试项目导入</li></ol><p>例如:<br>线下<br>配置Java环境(下载jdk并配置环境变量)<br>下载并安装中间件(tomcat jetty或其他)<br>安装数据库并导入初始化脚本<br>线上<br>Docker模式</p><ol><li>构建属于自己的image</li><li>一键deploy<br>依赖第三方平台</li></ol><h2 id="软件测试过程"><a href="#软件测试过程" class="headerlink" title="软件测试过程"></a>软件测试过程</h2><p><img src="/image/2019-08-25-09-15-03.jpg" alt></p><h3 id="测试过程划分"><a href="#测试过程划分" class="headerlink" title="测试过程划分"></a>测试过程划分</h3><ol><li>在逻辑上，测试活动按顺序进行</li><li>在实际测试过程中，这些活动是可以重叠或同时进行的</li></ol><h3 id="测试策划过程"><a href="#测试策划过程" class="headerlink" title="测试策划过程"></a>测试策划过程</h3><ol><li>确认测试的资源和技术需求</li><li>进行风险分析和评估</li><li>根据上述分析结果制定测试计划</li><li>根据测试计划开展相应的测试控制活动</li></ol><h2 id="需求测试"><a href="#需求测试" class="headerlink" title="需求测试"></a>需求测试</h2><p>原因: </p><ol><li>减少与开发人员交互，节省时间</li><li>早期确定测试用例的编写过程，为测试打好了基础</li><li>为测试用例设计提供帮助</li><li>可以发现需求不合理的地方，降低测试成本</li><li>明确哪些需求更重要</li><li>与风险承担着今早对项目达成共识</li><li>对需求更清晰</li></ol><h3 id="需求验证"><a href="#需求验证" class="headerlink" title="需求验证"></a>需求验证</h3><p>审查需求分档<br>以需求为依据编写测试用例<br>确定合格的标准</p><h3 id="需求规格说明书检查列表"><a href="#需求规格说明书检查列表" class="headerlink" title="需求规格说明书检查列表"></a>需求规格说明书检查列表</h3><p><img src="/image/2019-08-25-09-30-07.jpg" alt></p><h2 id="测试策略"><a href="#测试策略" class="headerlink" title="测试策略"></a>测试策略</h2><p>描述测试项目和测试任务之间的关系</p><h3 id="测试策略要素"><a href="#测试策略要素" class="headerlink" title="测试策略要素"></a>测试策略要素</h3><ol><li>测试安排、发布计划</li><li>测试范围(按优先级排列)</li><li>测试资源: 人力和工具</li><li>测试环境: 推荐环境解决方案、操作系统要求、软硬件要求</li><li>测试方法</li><li>文档管理</li><li>风险管理</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>百度测试开发一面</title>
      <link href="/2019/08/23/bai-du-ce-shi-kai-fa-yi-mian/"/>
      <url>/2019/08/23/bai-du-ce-shi-kai-fa-yi-mian/</url>
      
        <content type="html"><![CDATA[<ol><li>自我介绍</li><li>说说小程序(个人小程序项目)与其他项目开发的区别<br>小程序和网页开发都依赖JavaScript，但是所用的JavaScipt不同，正因为小程序没有DOM和BOM对象所以前端开发的一些库，例如JQuery、Zepto等在小程序中无法运行<br>网页开发者可以使用DOMAPI进行DOM选中和操作，小程序的逻辑层和渲染层是分开的，缺少DOM API 和 BOM API </li><li>软件测试理论</li><li>三次握手，四次挥手</li><li>知道哪些排序算法<br>(1) </li><li>手写快速排序</li><li>地址栏输入url发生了什么</li><li>HTTP协议和状态码</li><li>Java中的wait()和sleep()的区别</li><li>有哪些优点、哪些缺点</li><li>计算机网络的层次结构<br>网络需要解决的问题:<br>(1) 保证数据通路顺畅<br>(2) 识别目的计算机<br>(3) 目的计算机状态<br>(4) 数据是否错误<br>分层实现不同的功能<br>基本原则:<br>各层之间是相互独立度<br>每一层要有足够的灵活性<br>各层之间完全解耦<br>OSI 七层模型<br>应用层 为计算机用户提供接口和服务<br>表示层 数据处理(编码解码、加密解密)<br>会话层 管理(建立、维护、重连) 通信会话<br>传输层 管理端到端的通信<br>网络层 数据路由<br>数据链路层 管理相邻节点的数据通信<br>物理层 数据通信的光电物理通信<br>TCP / IP 四层模型<br>应用层 HTTP / FTP / SMTP / POP3<br>传输层 TCP/UDP<br>网络层 IP/ICMP<br>网络接口层 Ethernet / PPP<br>TCP / UDP<br>传输层 : 进程与进程的通信<br>使用端口来标记不同的网络进程 Port 16比特位(0~65535)<br>UDP协议详解 UDP协议详解<br>对数据不合并 不拆分<br>UDP 首部<br>16位源端口号:<br>16位目的端口号:<br>16位UDP 长度:<br>16位UDP 校验和<br>UDP 数据</li></ol><p>UDP是无连接协议:直接发送数据 无需连接<br>UDP 不能保证可靠的交付数据<br>UDP 是面向报文传输的 :直接把应用层数据塞进UDP数据报的数据<br>UDP 没有拥塞控制 不管网络是否拥挤<br>UDP 首部开销比较小 8个字节</p><p>TCP协议 传输控制协议<br>TCP是面向连接的协议<br>TCP的一个连接有两端(点对点通信)<br>TCP提供可靠的传输服务<br>TCP协议提供全双工的通信<br>TCP是面向字节流的协议:以字节位单位处理数据<br>TCP协议详解<br>头部固定有20个字节<br>16位源端口 16位目的端口<br>序号 0<del>2^32-1 数据报第一个字节的序号<br>确认号 0</del>2^32-1  期待收到的首字节序号<br>确认号为N : 则表示N-1序号的数据都已收到</p><p>数据偏移 占4位 0<del>15  单位为32位字 数据偏离首部的距离<br>15 *4 = 60<br>20</del>60个字节<br>TCP标记 占6位<br>URG\ACK\PSH\RSY\SYN\FIN<br>URG: 紧急位<br>ACK: 确认位 ACK = 1 确认号生效<br>PSH : PSH = 1 尽快的把数据传送到应用层<br>RST: RST = 1: 重新建立连接<br>SYN: SYN=1 表示连接请求报文<br>FIN: FIN=1 表示释放连接<br>窗口<br>占16位 0<del>2^16-1<br>窗口指明对方允许发送的数据量<br>确认号   窗口长度<br>501        100 501</del>1500<br>紧急指针 紧急数据在报文的位置 URG=1<br>TCP选项 最多有40个字节 支持未来的拓展</p><p>可靠传输的基本原理</p><ol><li>停止等待ARQ协议<br>超时重传，接受确认消息异常<br>发送的消息丢失、确认消息丢失、确认消息很久才到<br>可靠传输<br>超时定时器: 每发送一个消息，都需要设置一个定时器<br>停止等待协议对信道的利用率不高</li><li>连续ARQ协议(自动重传请求)<br>滑动窗口 累计确认 </li></ol><p>TCP可靠传输基于连续ARQ协议<br>TCP滑动窗口以字节位单位<br>选择重传: 指定重传的字节的边界</p><p>TCP协议的流量控制<br>让发送方发送的速率不要太快<br>流量控制是使用滑动窗口来实现的, 窗口指明允许对方发送的数据量<br>窗口请求数据丢失，可能会导致发送方和接受方互相等待，进入死锁的情况<br>当接受到窗口为0的消息，则启动坚持定时器，坚持定时器每隔一段时间发送一个窗口探测报文<br>考虑点对点的通信量的控制</p><p>TCP协议的拥塞控制<br>网络对硬件设备的性能要求大于硬件资源<br>拥塞控制整个网络，是全局性的考虑<br>慢启动算法:<br>由小到大逐渐增加发送数据量<br>每搜到一一个报文确认，就加一<br>1 2 4 8 16 指数增长<br>增长到慢启动阈值停止增长<br>拥塞避免算法<br>维护一个拥塞窗口的变量<br>只要网络不拥塞，就试探着拥塞窗口调大<br>1 2 4 8 16<br>17 18 19</p><p><img src="/image/2019-08-25-15-14-17.jpg" alt></p><p>TCP 三次握手<br>SYN=1,seq=x      连接请求，序列号<br>SYN=1,ACK=1,seq=y, ack=x+1 期望收到x+1开始的报文<br>ACK=1,seq=x+1,ack=y+1<br>建立连接、同步序号</p><p><img src="/image/2019-08-25-15-25-23.jpg" alt><br>为什么发送方要发出第三个确认报文呢？<br>避免已失效连接请求报文传送到对方，引起错误</p><p><img src="/image/2019-08-25-15-31-41.jpg" alt><br>TCP四次挥手</p><p><img src="/image/2019-08-25-15-38-10.jpg" alt><br>MSL:最长报文段寿命<br>MSL建议设置为2分钟<br>表现:释放连接后，端口等一段时间才能使用<br>为什么需要等待2MSL<br>确保发送方的ACK可以到达接收方<br>2MSL时间内没有收到，则接收方会重发<br>确保当前连接的所报文都已经过期</p><h2 id="套接字与套接字编程"><a href="#套接字与套接字编程" class="headerlink" title="套接字与套接字编程"></a>套接字与套接字编程</h2><p>{IP:Port}， 表示TCP连接的一端<br>TCP={Scocket1: Socket2}<br>       ={(IP:Port)} {(IP:Port)}<br>客户端和服务端通过TCP连接起来<br>服务端:创建套接字-&gt;绑定套接字-&gt; 监听套接字 -&gt;接受和处理信息<br>客户端: 创建套接字 -&gt; 连接套接字 -&gt; 发送消息</p><h2 id="域套接字和网络套接字的区别"><a href="#域套接字和网络套接字的区别" class="headerlink" title="域套接字和网络套接字的区别"></a>域套接字和网络套接字的区别</h2><p>12、对Python的了解程度 是否写过爬虫</p><p>13知道哪些Linux命令</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统基础</title>
      <link href="/2019/08/22/cao-zuo-xi-tong-ji-chu/"/>
      <url>/2019/08/22/cao-zuo-xi-tong-ji-chu/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h2><p>管理硬件，实现用户交互的系统软件</p><h2 id="操作系统相关概念"><a href="#操作系统相关概念" class="headerlink" title="操作系统相关概念"></a>操作系统相关概念</h2><p>并发性 多道程序交替运行<br>共享性 操作系统资源可以供多个并发的程序共享<br>互斥共享、同时访问(宏观)<br>虚拟性: 物理实体转变为若干个逻辑实体<br>时分复用: 多个程序分时复用处理器、多个程序通过逻辑设备并发访问<br>空分复用: 虚拟磁盘、虚拟内存<br>虚拟磁盘: 物理磁盘虚拟为逻辑磁盘，CDE<br>虚拟内存: 使用比实际内存更大的容量<br>异步性: 进程的执行不是一气呵成，资源抢占，进程以不可预知的速度进行</p><h2 id="进程管理之进程实体"><a href="#进程管理之进程实体" class="headerlink" title="进程管理之进程实体"></a>进程管理之进程实体</h2><h3 id="为什么需要进程"><a href="#为什么需要进程" class="headerlink" title="为什么需要进程"></a>为什么需要进程</h3><ol><li>资源分配和调度的基本单位</li><li>独立运行的载体</li><li>资源利用率大幅提升<h3 id="进程实体"><a href="#进程实体" class="headerlink" title="进程实体"></a>进程实体</h3>PCB:<br>标识符:唯一标记进程<br>状态: 进程状态<br>程序计数器: 下一条指令地址<br>内存指针: 指向程序或数据地址<br>上下文数据: 进程执行时，处理器存储的数据<br>IO状态信息: IO操作占用的文杰列表<br>记账信息: 使用处理器实际、时钟数总和<h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3>线程是操作系统进行运行调度的最小单位<br>一个进程可以并发多个线程<br>进程通信: 进程IPC<br>线程通信: 读写同一进程数据通信<h3 id="进程管理之五状态模型"><a href="#进程管理之五状态模型" class="headerlink" title="进程管理之五状态模型"></a>进程管理之五状态模型</h3>就绪: 被分配资源 只差CPU资源<br>就绪队列: 多个就绪进程<br>执行: 进程获取CPU<br>阻塞: 放弃CPU状态 阻塞队列<br>就绪-&gt; 进程调度 -&gt; 执行 -&gt; 时间片完-&gt; 就绪<br>执行-&gt; IO请求 -&gt; 阻塞 -&gt; I/O完成 -&gt; 就绪<br>创建: 分配PCB -&gt; 插入就绪队列 (分配PCB，但其他资源还有待分配)<br>终止: 系统清理 -&gt; 归还PCB<h3 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h3>生产者消费者问题</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试基础知识</title>
      <link href="/2019/08/22/ruan-jian-ce-shi-ji-chu-zhi-shi/"/>
      <url>/2019/08/22/ruan-jian-ce-shi-ji-chu-zhi-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="软件的概念"><a href="#软件的概念" class="headerlink" title="软件的概念"></a>软件的概念</h2><p>软件是计算机系统中与硬件相互依存的另一部分，它是包括程序，数据及其相关文档的完整集合<br>程序:<br>数据<br>文档</p><h2 id="软件的十大特性"><a href="#软件的十大特性" class="headerlink" title="软件的十大特性"></a>软件的十大特性</h2><p>形态特性、智能特性、开发特性、<br>质量特性:存在缺陷<br>生产特性:复制简单 成本低<br>管理特性:<br>环境特性: 软件开发和运行需要计算机系统的环境<br>维护特性: 升级、优化、功能更新、重构<br>废弃特性: 不会因被“用坏”而被废弃<br>应用特性: 应用极为广泛 </p><h2 id="软件的分类"><a href="#软件的分类" class="headerlink" title="软件的分类"></a>软件的分类</h2><p>系统软件: 操作系统、数据库管理软件<br>应用软件: QQ 图像浏览器</p><h2 id="软件的生命周期"><a href="#软件的生命周期" class="headerlink" title="软件的生命周期"></a>软件的生命周期</h2><p>问题定义-&gt;可行性研究-&gt;需求分析-&gt;概要设计-&gt;详细设计-&gt;编码和单元测试-&gt;综合测试-&gt;软件维护</p><h2 id="软件开发模型"><a href="#软件开发模型" class="headerlink" title="软件开发模型"></a>软件开发模型</h2><h3 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h3><p>计划-&gt;需求分析-&gt;设计-&gt;编码-&gt;测试-&gt;运行维护<br>特点 :</p><ol><li>软件开发的各项活动严格按照线性方式进行。</li><li>当前活动接受上一项的工作结果 。</li><li>当前活动的工作结果需要进行验证</li></ol><p>缺陷:</p><ol><li>增加开发的风险</li><li>早期的错误可能要等到开发后期的阶段才能发现</li></ol><h3 id="原型模型"><a href="#原型模型" class="headerlink" title="原型模型"></a>原型模型</h3><p>开发周期长。开发会收到需求变更的影响<br>特点:</p><ol><li>实现客户与系统的交互</li><li>进一步细化软件开发需求</li><li>开发人员可以确定客户的真正需求是什么</li></ol><h3 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h3><p>制定计划 -&gt; 风险分析 -&gt; 实施工程 -&gt; 客户评估<br>特点:</p><ol><li>螺旋模型是将瀑布模型与快速原型模型结合起来</li><li>强调了其他模型所忽视的风险分析</li><li>每一次螺旋包括4个步骤: 制定计划 -&gt; 风险分析 -&gt; 实施工程 -&gt; 客户评估</li></ol><p>缺点:<br>风险用户不太能接受</p><h3 id="敏捷模型"><a href="#敏捷模型" class="headerlink" title="敏捷模型"></a>敏捷模型</h3><p>特点: 短周期开发 增量开发<br>由程序员和测试人员编写的自动化测试来监控开发进度<br>通过口头沟通、测试先行<br>人员素质要求比较高<br>测试员掌握各种脚本语言脚本编程、能执行单元测试、自动化测试</p><h3 id="软件开发文档"><a href="#软件开发文档" class="headerlink" title="软件开发文档"></a>软件开发文档</h3><p>需求分析文档<br>概要设计文档<br>详细设计文档<br>测试计划<br>测试用例设计<br>测试报告</p><h3 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h3><p>在规定条件下对程序进行操作 已发现程序错误 衡量软件质量 评估<br>弄清预期结果与实际结果的区别</p><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>发现问题，检查系统是否满足需求</p><h3 id="软件测试的方法和分类"><a href="#软件测试的方法和分类" class="headerlink" title="软件测试的方法和分类"></a>软件测试的方法和分类</h3><h4 id="按生命周期划分"><a href="#按生命周期划分" class="headerlink" title="按生命周期划分"></a>按生命周期划分</h4><p>单元测试: 编码人员测试<br>冒烟测试: 主要流程测试<br>集成测试:<br>系统测试:<br>验收测试<br>按测试方法划分:<br>白盒测试:静态测试、动态分析: 逻辑覆盖测试、插桩测试<br>黑盒测试: 功能测试、自动化测试、性能测试、安全测试<br>灰盒测试:<br>其他:随机测试(客户、非专业人员测试)、探索性测试、阿尔法测试 β测试(验收类型测试)</p><p><img src="/image/2019-08-24-20-17-18.jpg" alt></p><h3 id="软件测试属于"><a href="#软件测试属于" class="headerlink" title="软件测试属于"></a>软件测试属于</h3><p>C/S 客户端软件/服务端软件<br>B/S 浏览器/服务器<br>测试环境 : 软件 + 硬件 + 网络<br>测试用例: 输入(数据和操作步骤) + 输出(预期结果) + 测试环境<br>冒烟测试: 在大规模测试前先进行基本的测试，看是否具有可测性<br>α测试: 内部测试<br>β测试: 最终用户测试 公测</p><h3 id="软件测试模型"><a href="#软件测试模型" class="headerlink" title="软件测试模型"></a>软件测试模型</h3><p>V模型 开发测试并行进行，编码之后<br>W模型 测试过程伴随整个开发周期，测试开发同步执行<br>H模型 测试级别之间不存在次序关系<br>X模型 分块化探索性测试，分成程序片段</p><h3 id="软件测试覆盖率"><a href="#软件测试覆盖率" class="headerlink" title="软件测试覆盖率"></a>软件测试覆盖率</h3><p>覆盖率 = (至少被执行一次的item数) / item总数</p><ol><li>通过覆盖率数据，可以检测我们的测试是否充分</li><li>分析出测试的弱点在哪里</li><li>指导增加测试用例</li></ol><p>需求覆盖: 需求点被验证<br>用例覆盖: 验证通过的用例数量 / 总的用例总数 80%</p><h3 id="软件测试的原则"><a href="#软件测试的原则" class="headerlink" title="软件测试的原则"></a>软件测试的原则</h3><ol><li>所有的测试都应该追溯到用户的需求</li><li>尽早启动测试工作</li><li>Pareto法则</li><li>穷尽测试是不可能的</li><li>杀虫剂怪事</li><li>前进两步，后退一步</li><li>三心二意 细心、信心、耐心 沟通意识、缺陷预防意识</li></ol><h3 id="软件测试规范"><a href="#软件测试规范" class="headerlink" title="软件测试规范"></a>软件测试规范</h3><ol><li>测试管理 资源管理 配置管理 测试规划 测试实施</li><li>角色的确定、进入的准则、输入项、活动过程、输出项、验证与确认、退出的准则</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型与原型链</title>
      <link href="/2019/08/11/yuan-xing-yu-yuan-xing-lian/"/>
      <url>/2019/08/11/yuan-xing-yu-yuan-xing-lian/</url>
      
        <content type="html"><![CDATA[<p>在JavaScript中， 每个实例对象都有一个私有属性，_<em>proto_</em>, 指向它的构造函数的原型对象。<br>例如</p><pre><code>var num = new Number(&quot;1&quot;)// 此时num存在一个私有属性__proto__指向Number的prototype</code></pre><p>在上例中的原型对象Number中也有自己的原型对象(__prorp__),指向Object的原型对象prototype<br>诸如此类的还有构造方法String(), Boolean(). 它们层层向上，直到一个对象的原型对象为null，null没有原型，作为原型链中的最后一个环节<br>JavaScript对象有一个指向一个原型对象的链。 当试图访问一个对象的属性时，它不仅仅在该对象上搜索，还会搜寻该对象的原型，以及对象的原型的原型，依次层层向上搜索，直到找到一个属性的名字匹配的属性或到达原型链的末尾</p><p><img src="/image/2019-08-11-16-24-13.jpg" alt><br>图中打印Number对象的结果，它包含一个__proto__私有属性，指向Number的prototype, 在下方还有一个__proto__属性，它指向Object的prototype，所以存在:</p><pre><code>var num = new Number(&quot;1&quot;)num.__proto__ === Number.prototype; \\ truenum.__proto__.__proto__ === Object.prototype; \\ trueNumber.prototype.__proto__ === Object.prototype \\ truevar obj = new Object();obj.__proto__ === Object.prototype \\ true</code></pre><p>注意:</p><ol><li>Object._<em>proto_</em> === Function.prototype  Function 是Object的构造函数</li><li>Object.prototype._<em>proto_</em> 指向null<br>总结:<br>原型链的存在使得不同的实例对象可以继承来自原型的相同的公用方法与属性。避免了重复声明与编写方法，降低了内存的占用</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>普通类型和对象的区别</title>
      <link href="/2019/08/08/pu-tong-lei-xing-he-dui-xiang-de-qu-bie/"/>
      <url>/2019/08/08/pu-tong-lei-xing-he-dui-xiang-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<blockquote><p>JS引擎将内存分为代码区和数据区，数据区分为Stack(栈)和Heap(堆) 普通类型的的数据直接存在在Stack中，而对象存放在堆中，这是普通类型和对象的重要区别</p></blockquote><h2 id="对象在内存中的存放"><a href="#对象在内存中的存放" class="headerlink" title="对象在内存中的存放"></a>对象在内存中的存放</h2><h3 id="例1"><a href="#例1" class="headerlink" title="例1:"></a>例1:</h3><pre><code>var a = {name: &#39;a&#39;}var b = ab = {name: &#39;b&#39;}a.name 是多少？</code></pre><p><img src="/image/2019-08-09-09-52-03.jpg" alt></p><p>var a = {name: ‘a’}<br>var b = a<br>此时a和b指向同一块内存</p><p><img src="/image/2019-08-09-09-55-49.jpg" alt><br> b = {name: ‘b’}<br>此时b指向的内存地址发生了变化<br>答案:b的name 为b</p><h3 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>name<span class="token punctuation">:</span> <span class="token string">'a'</span><span class="token punctuation">}</span><span class="token keyword">var</span> b <span class="token operator">=</span> ab<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'b'</span></code></pre><p><img src="/image/2019-08-09-10-01-27.jpg" alt><br>b指向的地址未发生改变，b.name 改成 ‘b’， 因为a与b指向同一块内存地址，所以a.name也为’b’</p><h3 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>name<span class="token punctuation">:</span> <span class="token string">'a'</span><span class="token punctuation">}</span><span class="token keyword">var</span> b <span class="token operator">=</span> ab <span class="token operator">=</span> <span class="token keyword">null</span></code></pre><p>a的值为？</p><p><img src="/image/2019-08-09-10-04-40.jpg" alt><br>b 的值为null, a的值为{name:’a’}</p><h3 id="例4"><a href="#例4" class="headerlink" title="例4"></a>例4</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>n<span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token keyword">var</span> b <span class="token operator">=</span> aa<span class="token punctuation">.</span>x <span class="token operator">=</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>n<span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token function">alert</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>x<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// --> undefined</span><span class="token function">alert</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>x<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// --> [object Object]</span></code></pre><p>刚开始 a,b存放同一块内存地址，之后a.x 存放 a的新地址，但在对a.x赋值时，a.x仍在旧的内存块中, <strong>不能单纯的从右往左看</strong></p><p><img src="/image/2019-08-09-10-29-48.jpg" alt><br>此时，a指向新的内存地址块，但是并没有x属性，所以为undefined, b 仍指向之前的地址块， b.x 指向 a的新地址</p><h2 id="GC垃圾回收"><a href="#GC垃圾回收" class="headerlink" title="GC垃圾回收"></a>GC垃圾回收</h2><blockquote><p>如果一个对象没有被引用，它就是’垃圾’，将被回收</p></blockquote><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>name<span class="token punctuation">:</span><span class="token string">'a'</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token punctuation">{</span>name<span class="token punctuation">:</span><span class="token string">'b'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>b <span class="token operator">=</span> a<span class="token punctuation">;</span></code></pre><p>此时，{name:’b’} 没有任何被任何变量引用，它将被回收。<br>当一个标签页被关闭时，页面中的所有对象分配的内存都会被回收，当然也有例外，<strong>在ES6中，只有关闭整个浏览器，垃圾内存才会回收</strong></p><h2 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h2><p>例:</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>b <span class="token operator">=</span> a<span class="token punctuation">;</span>a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span></code></pre><p>此时b的值仍为2，没有受a值变化的影响，我们称为深拷贝，普通类型赋值就是深拷贝。<br>对象需要区分深拷贝与浅拷贝</p><pre><code>var a = {name:&#39;a&#39;};var b = {name:&#39;b&#39;};b = a;a.name = &#39;c&#39;;b.name === &#39;c&#39; \\ true</code></pre><p>此时b.name的值为’c’ , 因为对象的赋值操作是浅拷贝</p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS里的数据类型转换</title>
      <link href="/2019/08/08/js-li-de-shu-ju-lei-xing-zhuan-huan/"/>
      <url>/2019/08/08/js-li-de-shu-ju-lei-xing-zhuan-huan/</url>
      
        <content type="html"><![CDATA[<h2 id="1-任意类型转字符串"><a href="#1-任意类型转字符串" class="headerlink" title="1 任意类型转字符串"></a>1 任意类型转字符串</h2><h3 id="1-1-使用String-方法"><a href="#1-1-使用String-方法" class="headerlink" title="1.1 使用String() 方法"></a>1.1 使用String() 方法</h3><pre><code>String(1) //&quot;1&quot;String(true) //&quot;true&quot;String(null) //&quot;null&quot;String(undefined) //&quot;undefined&quot;String({}) //&quot;[object Object]&quot;</code></pre><h3 id="1-2-使用toString-方法"><a href="#1-2-使用toString-方法" class="headerlink" title="1.2 使用toString()方法"></a>1.2 使用toString()方法</h3><pre><code>(1).toString()&quot;1&quot;true.toString()&quot;true&quot;null.toString()// 无法转换 报错 : Uncaught TypeError: Cannot read property &#39;toString&#39; of nullundefined.toString()// 无法转换 报错 : Uncaught TypeError: Cannot read property &#39;toString&#39; of undefined({}).toString()&quot;[object Object]&quot;</code></pre><h3 id="1-3-使用x-‘’"><a href="#1-3-使用x-‘’" class="headerlink" title="1.3 使用x + ‘’"></a>1.3 使用x + ‘’</h3><p>结果同使用String()</p><h2 id="2-任意类型转换数字"><a href="#2-任意类型转换数字" class="headerlink" title="2 任意类型转换数字"></a>2 任意类型转换数字</h2><h3 id="2-1-使用Number"><a href="#2-1-使用Number" class="headerlink" title="2.1 使用Number()"></a>2.1 使用Number()</h3><pre><code>Number(true) // 1Number(null) // 0Number(undefined) // NaNNumber({}) // NaNNumber(&quot;1&quot;) // 1</code></pre><h3 id="2-2-使用parseInt"><a href="#2-2-使用parseInt" class="headerlink" title="2.2 使用parseInt"></a>2.2 使用parseInt</h3><p>用于将字符串转化为数字, 第一个参数为要转化的字符串，第二个参数为进制，例子中为十进制</p><pre><code>parseInt(&quot;1&quot;, 10) // 1parseInt(&quot;1a&quot;, 10) // 1parseInt(&quot;a1&quot;, 10) // NaN</code></pre><h3 id="2-3-使用parseFloat"><a href="#2-3-使用parseFloat" class="headerlink" title="2.3 使用parseFloat"></a>2.3 使用parseFloat</h3><p>用于将字符串转化为浮点数</p><h3 id="2-4-使用x-0"><a href="#2-4-使用x-0" class="headerlink" title="2.4 使用x - 0"></a>2.4 使用x - 0</h3><pre><code>&#39;18&#39; - 018true - 01false - 00</code></pre><h2 id="3-任意类型转布尔值"><a href="#3-任意类型转布尔值" class="headerlink" title="3 任意类型转布尔值"></a>3 任意类型转布尔值</h2><h3 id="3-1-使用Boolean"><a href="#3-1-使用Boolean" class="headerlink" title="3.1 使用Boolean()"></a>3.1 使用Boolean()</h3><pre><code>Boolean(1) // trueBoolean(NaN) // falseBoolean(0) // falseBoolean(&#39;&#39;) // falseBoolean(&#39;1&#39;) // trueBoolean(null) // falseBoolean(undefined) // false</code></pre><h3 id="3-2-使用-x"><a href="#3-2-使用-x" class="headerlink" title="3.2 使用!!x"></a>3.2 使用!!x</h3><pre><code>!!&#39;&#39; // false!!NaN // false</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS里的数据类型</title>
      <link href="/2019/08/05/js-li-de-shu-ju-lei-xing/"/>
      <url>/2019/08/05/js-li-de-shu-ju-lei-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>JavaScript共有七种数据类型，分别是:</p><ul><li>数值(number)</li><li>字符串(string)</li><li>布尔值(boolean)</li><li>undefined</li><li>null</li><li>对象(object)<br>其中对象又称为合成类型，它经常由其他的基本类型组成</li></ul><h2 id="2-number类型"><a href="#2-number类型" class="headerlink" title="2. number类型"></a>2. number类型</h2><p>JavaScript内部 ，所有数字都以64位浮点数形式存储，不存在整数，所以有1 === 1.0 //true,<br>由于浮点数不是精确的值，所以涉及小数的比较和运算需要注意，如:</p><pre><code>0.1 + 0.2  // 0.30000000000000004</code></pre><h3 id="2-2-数值表示法"><a href="#2-2-数值表示法" class="headerlink" title="2.2 数值表示法"></a>2.2 数值表示法</h3><p>(1) 科学计数<br>数值可以采用科学记数法表示，如</p><pre><code>123e3 //123000123e-3 //0.123</code></pre><p>(2) 进制<br>0o表示八进制，0x表示16进制，0b表示2进制</p><pre><code>0xff // 2550o377 // 2550b11 //3</code></pre><h2 id="3-object"><a href="#3-object" class="headerlink" title="3. object"></a>3. object</h2><p>对象中的所有键名都是字符串，当键名是数值时，会被自动转为字符串.如果字符串符合标识符的定义，可以省略’’</p><pre><code>let obj = {    0:&#39;A&#39;,    1:&#39;B&#39;    }obj[0] // &#39;A&#39; </code></pre><p>当键名不符合标识符的条件时，需要加上引号 如</p><pre><code>let obj = {    &#39;1a&#39;:&#39;A&#39;,    &#39;a b&#39;:&#39;B&#39;    &#39;c+&#39;:&#39;C&#39;</code></pre><p>对象可以包含对象，设置可以包含本身</p><pre><code>let obj = {    name:&#39;zbdxsyf&#39;,    age: 18,        }</code></pre><p>对象读取属性有两种方法，一种是使用.运算符，还有一种是使用方括号</p><pre><code>let obj = {    p: &#39;Hello World&#39;    };obj.pobj[&#39;p&#39;]</code></pre><p>数字键名在方括号中加不加引号都可以，因为会自动转化为字符串,数字键名不能使用点运算符，因为有可能被当成小数<br>属性的遍历可以使用for…in循环，<br>使用for in 循环遍历对象</p><pre><code>let obj = {}for (let p in obj){    console.log(p,obj[p]) //不能使用obj.p, 因为obj.p会转化为obj[&#39;p&#39;],p是变量不是字符串    }</code></pre><p>得到obj对应的键值对<br>可以使用delete 命令来删除对象中的键值对，删除成功后返回true<br>使用delete需要注意:<br>delete删除一个不存在的属性不会报错，且返回true</p><pre><code>let obj = {}delete obj.p //true</code></pre><h2 id="5-undefined-null"><a href="#5-undefined-null" class="headerlink" title="5. undefined null"></a>5. undefined null</h2><p>null与undefined有以下区别:</p><ol><li>当变量声明未赋值时，变量的值为undefined</li><li>如果对象为空时，我们一般赋值为null 而不是undefined</li></ol><h2 id="4-typeof运算符"><a href="#4-typeof运算符" class="headerlink" title="4. typeof运算符"></a>4. typeof运算符</h2><p>使用typeof可以查看一个值的数据类型，但是存在如下问题:</p><ol><li>typeof(null) 的值为object</li><li>typeof(function)的值为function<br>事实上， null 为一种单独的数据类型，而function属于object类型</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>更换了主题</title>
      <link href="/2019/08/04/geng-huan-liao-zhu-ti/"/>
      <url>/2019/08/04/geng-huan-liao-zhu-ti/</url>
      
        <content type="html"><![CDATA[<p>选择了一个新的主题，发表文章测试一下</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>article title</title>
      <link href="/2019/08/04/article-title/"/>
      <url>/2019/08/04/article-title/</url>
      
        <content type="html"><![CDATA[<p>Hello World!</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/08/04/hello-world/"/>
      <url>/2019/08/04/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
