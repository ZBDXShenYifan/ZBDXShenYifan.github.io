<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>软件测试流程</title>
      <link href="/2019/08/25/ruan-jian-ce-shi-liu-cheng/"/>
      <url>/2019/08/25/ruan-jian-ce-shi-liu-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="搭建测试环境"><a href="#搭建测试环境" class="headerlink" title="搭建测试环境"></a>搭建测试环境</h2><h3 id="搭建测试环境前"><a href="#搭建测试环境前" class="headerlink" title="搭建测试环境前"></a>搭建测试环境前</h3><ol><li>确认测试目的<br>功能测试: 不需要大量数据，需要覆盖率高，测试数据要求尽量真实<br>性能测试: 大量存量数据或者与硬件环境尽可能相似的硬件配置</li><li>测试的软件环境尽可能模拟真实环境</li><li>了解符合测试软件运行的最低要求及用户使用的硬件配置</li><li>产品化的测试需要考虑兼容性方案</li><li>营造独立的测试环境</li><li>构建可复用的测试环境: 构建可复用的测试环境</li></ol><h3 id="搭建环境过程分析"><a href="#搭建环境过程分析" class="headerlink" title="搭建环境过程分析"></a>搭建环境过程分析</h3><ol><li>线下搭建</li><li>独立测试服务器或虚拟机</li><li>测试环境配置</li><li>测试项目导入</li></ol><p>例如:<br>线下<br>配置Java环境(下载jdk并配置环境变量)<br>下载并安装中间件(tomcat jetty或其他)<br>安装数据库并导入初始化脚本<br>线上<br>Docker模式</p><ol><li>构建属于自己的image</li><li>一键deploy<br>依赖第三方平台</li></ol><h2 id="软件测试过程"><a href="#软件测试过程" class="headerlink" title="软件测试过程"></a>软件测试过程</h2><p><img src="/image/2019-08-25-09-15-03.jpg" alt></p><h3 id="测试过程划分"><a href="#测试过程划分" class="headerlink" title="测试过程划分"></a>测试过程划分</h3><ol><li>在逻辑上，测试活动按顺序进行</li><li>在实际测试过程中，这些活动是可以重叠或同时进行的</li></ol><h3 id="测试策划过程"><a href="#测试策划过程" class="headerlink" title="测试策划过程"></a>测试策划过程</h3><ol><li>确认测试的资源和技术需求</li><li>进行风险分析和评估</li><li>根据上述分析结果制定测试计划</li><li>根据测试计划开展相应的测试控制活动</li></ol><h2 id="需求测试"><a href="#需求测试" class="headerlink" title="需求测试"></a>需求测试</h2><p>原因: </p><ol><li>减少与开发人员交互，节省时间</li><li>早期确定测试用例的编写过程，为测试打好了基础</li><li>为测试用例设计提供帮助</li><li>可以发现需求不合理的地方，降低测试成本</li><li>明确哪些需求更重要</li><li>与风险承担着今早对项目达成共识</li><li>对需求更清晰</li></ol><h3 id="需求验证"><a href="#需求验证" class="headerlink" title="需求验证"></a>需求验证</h3><p>审查需求分档<br>以需求为依据编写测试用例<br>确定合格的标准</p><h3 id="需求规格说明书检查列表"><a href="#需求规格说明书检查列表" class="headerlink" title="需求规格说明书检查列表"></a>需求规格说明书检查列表</h3><p><img src="/image/2019-08-25-09-30-07.jpg" alt></p><h2 id="测试策略"><a href="#测试策略" class="headerlink" title="测试策略"></a>测试策略</h2><p>描述测试项目和测试任务之间的关系</p><h3 id="测试策略要素"><a href="#测试策略要素" class="headerlink" title="测试策略要素"></a>测试策略要素</h3><ol><li>测试安排、发布计划</li><li>测试范围(按优先级排列)</li><li>测试资源: 人力和工具</li><li>测试环境: 推荐环境解决方案、操作系统要求、软硬件要求</li><li>测试方法</li><li>文档管理</li><li>风险管理</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>百度测试开发一面</title>
      <link href="/2019/08/23/bai-du-ce-shi-kai-fa-yi-mian/"/>
      <url>/2019/08/23/bai-du-ce-shi-kai-fa-yi-mian/</url>
      
        <content type="html"><![CDATA[<ol><li>自我介绍</li><li>说说小程序(个人小程序项目)与其他项目开发的区别<br>小程序和网页开发都依赖JavaScript，但是所用的JavaScipt不同，正因为小程序没有DOM和BOM对象所以前端开发的一些库，例如JQuery、Zepto等在小程序中无法运行<br>网页开发者可以使用DOMAPI进行DOM选中和操作，小程序的逻辑层和渲染层是分开的，缺少DOM API 和 BOM API </li><li>软件测试理论</li><li>三次握手，四次挥手</li><li>知道哪些排序算法<br>(1) </li><li>手写快速排序</li><li>地址栏输入url发生了什么</li><li>HTTP协议和状态码</li><li>Java中的wait()和sleep()的区别</li><li>有哪些优点、哪些缺点</li><li>计算机网络的层次结构<br>网络需要解决的问题:<br>(1) 保证数据通路顺畅<br>(2) 识别目的计算机<br>(3) 目的计算机状态<br>(4) 数据是否错误<br>分层实现不同的功能<br>基本原则:<br>各层之间是相互独立度<br>每一层要有足够的灵活性<br>各层之间完全解耦<br>OSI 七层模型<br>应用层 为计算机用户提供接口和服务<br>表示层 数据处理(编码解码、加密解密)<br>会话层 管理(建立、维护、重连) 通信会话<br>传输层 管理端到端的通信<br>网络层 数据路由<br>数据链路层 管理相邻节点的数据通信<br>物理层 数据通信的光电物理通信<br>TCP / IP 四层模型<br>应用层 HTTP / FTP / SMTP / POP3<br>传输层 TCP/UDP<br>网络层 IP/ICMP<br>网络接口层 Ethernet / PPP<br>TCP / UDP<br>传输层 : 进程与进程的通信<br>使用端口来标记不同的网络进程 Port 16比特位(0~65535)<br>UDP协议详解 UDP协议详解<br>对数据不合并 不拆分<br>UDP 首部<br>16位源端口号:<br>16位目的端口号:<br>16位UDP 长度:<br>16位UDP 校验和<br>UDP 数据</li></ol><p>UDP是无连接协议:直接发送数据 无需连接<br>UDP 不能保证可靠的交付数据<br>UDP 是面向报文传输的 :直接把应用层数据塞进UDP数据报的数据<br>UDP 没有拥塞控制 不管网络是否拥挤<br>UDP 首部开销比较小 8个字节</p><p>TCP协议 传输控制协议<br>TCP是面向连接的协议<br>TCP的一个连接有两端(点对点通信)<br>TCP提供可靠的传输服务<br>TCP协议提供全双工的通信<br>TCP是面向字节流的协议:以字节位单位处理数据<br>TCP协议详解<br>头部固定有20个字节<br>16位源端口 16位目的端口<br>序号 0<del>2^32-1 数据报第一个字节的序号<br>确认号 0</del>2^32-1  期待收到的首字节序号<br>确认号为N : 则表示N-1序号的数据都已收到</p><p>数据偏移 占4位 0<del>15  单位为32位字 数据偏离首部的距离<br>15 *4 = 60<br>20</del>60个字节<br>TCP标记 占6位<br>URG\ACK\PSH\RSY\SYN\FIN<br>URG: 紧急位<br>ACK: 确认位 ACK = 1 确认号生效<br>PSH : PSH = 1 尽快的把数据传送到应用层<br>RST: RST = 1: 重新建立连接<br>SYN: SYN=1 表示连接请求报文<br>FIN: FIN=1 表示释放连接<br>窗口<br>占16位 0<del>2^16-1<br>窗口指明对方允许发送的数据量<br>确认号   窗口长度<br>501        100 501</del>1500<br>紧急指针 紧急数据在报文的位置 URG=1<br>TCP选项 最多有40个字节 支持未来的拓展</p><p>可靠传输的基本原理</p><ol><li>停止等待ARQ协议<br>超时重传，接受确认消息异常<br>发送的消息丢失、确认消息丢失、确认消息很久才到<br>可靠传输<br>超时定时器: 每发送一个消息，都需要设置一个定时器<br>停止等待协议对信道的利用率不高</li><li>连续ARQ协议(自动重传请求)<br>滑动窗口 累计确认 </li></ol><p>TCP可靠传输基于连续ARQ协议<br>TCP滑动窗口以字节位单位<br>选择重传: 指定重传的字节的边界</p><p>TCP协议的流量控制<br>让发送方发送的速率不要太快<br>流量控制是使用滑动窗口来实现 的</p><p>12、对Python的了解程度 是否写过爬虫</p><p>13知道哪些Linux命令</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统基础</title>
      <link href="/2019/08/22/cao-zuo-xi-tong-ji-chu/"/>
      <url>/2019/08/22/cao-zuo-xi-tong-ji-chu/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h2><p>管理硬件，实现用户交互的系统软件</p><h2 id="操作系统相关概念"><a href="#操作系统相关概念" class="headerlink" title="操作系统相关概念"></a>操作系统相关概念</h2><p>并发性 多道程序交替运行<br>共享性 操作系统资源可以供多个并发的程序共享<br>互斥共享、同时访问(宏观)<br>虚拟性: 物理实体转变为若干个逻辑实体<br>时分复用: 多个程序分时复用处理器、多个程序通过逻辑设备并发访问<br>空分复用: 虚拟磁盘、虚拟内存<br>虚拟磁盘: 物理磁盘虚拟为逻辑磁盘，CDE<br>虚拟内存: 使用比实际内存更大的容量<br>异步性: 进程的执行不是一气呵成，资源抢占，进程以不可预知的速度进行</p><h2 id="进程管理之进程实体"><a href="#进程管理之进程实体" class="headerlink" title="进程管理之进程实体"></a>进程管理之进程实体</h2><h3 id="为什么需要进程"><a href="#为什么需要进程" class="headerlink" title="为什么需要进程"></a>为什么需要进程</h3><ol><li>资源分配和调度的基本单位</li><li>独立运行的载体</li><li>资源利用率大幅提升<h3 id="进程实体"><a href="#进程实体" class="headerlink" title="进程实体"></a>进程实体</h3>PCB:<br>标识符:唯一标记进程<br>状态: 进程状态<br>程序计数器: 下一条指令地址<br>内存指针: 指向程序或数据地址<br>上下文数据: 进程执行时，处理器存储的数据<br>IO状态信息: IO操作占用的文杰列表<br>记账信息: 使用处理器实际、时钟数总和<h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3>线程是操作系统进行运行调度的最小单位<br>一个进程可以并发多个线程<br>进程通信: 进程IPC<br>线程通信: 读写同一进程数据通信<h3 id="进程管理之五状态模型"><a href="#进程管理之五状态模型" class="headerlink" title="进程管理之五状态模型"></a>进程管理之五状态模型</h3>就绪: 被分配资源 只差CPU资源<br>就绪队列: 多个就绪进程<br>执行: 进程获取CPU<br>阻塞: 放弃CPU状态 阻塞队列<br>就绪-&gt; 进程调度 -&gt; 执行 -&gt; 时间片完-&gt; 就绪<br>执行-&gt; IO请求 -&gt; 阻塞 -&gt; I/O完成 -&gt; 就绪<br>创建: 分配PCB -&gt; 插入就绪队列 (分配PCB，但其他资源还有待分配)<br>终止: 系统清理 -&gt; 归还PCB<h3 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h3>生产者消费者问题</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试基础知识</title>
      <link href="/2019/08/22/ruan-jian-ce-shi-ji-chu-zhi-shi/"/>
      <url>/2019/08/22/ruan-jian-ce-shi-ji-chu-zhi-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="软件的概念"><a href="#软件的概念" class="headerlink" title="软件的概念"></a>软件的概念</h2><p>软件是计算机系统中与硬件相互依存的另一部分，它是包括程序，数据及其相关文档的完整集合<br>程序:<br>数据<br>文档</p><h2 id="软件的十大特性"><a href="#软件的十大特性" class="headerlink" title="软件的十大特性"></a>软件的十大特性</h2><p>形态特性、智能特性、开发特性、<br>质量特性:存在缺陷<br>生产特性:复制简单 成本低<br>管理特性:<br>环境特性: 软件开发和运行需要计算机系统的环境<br>维护特性: 升级、优化、功能更新、重构<br>废弃特性: 不会因被“用坏”而被废弃<br>应用特性: 应用极为广泛 </p><h2 id="软件的分类"><a href="#软件的分类" class="headerlink" title="软件的分类"></a>软件的分类</h2><p>系统软件: 操作系统、数据库管理软件<br>应用软件: QQ 图像浏览器</p><h2 id="软件的生命周期"><a href="#软件的生命周期" class="headerlink" title="软件的生命周期"></a>软件的生命周期</h2><p>问题定义-&gt;可行性研究-&gt;需求分析-&gt;概要设计-&gt;详细设计-&gt;编码和单元测试-&gt;综合测试-&gt;软件维护</p><h2 id="软件开发模型"><a href="#软件开发模型" class="headerlink" title="软件开发模型"></a>软件开发模型</h2><h3 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h3><p>计划-&gt;需求分析-&gt;设计-&gt;编码-&gt;测试-&gt;运行维护<br>特点 :</p><ol><li>软件开发的各项活动严格按照线性方式进行。</li><li>当前活动接受上一项的工作结果 。</li><li>当前活动的工作结果需要进行验证</li></ol><p>缺陷:</p><ol><li>增加开发的风险</li><li>早期的错误可能要等到开发后期的阶段才能发现</li></ol><h3 id="原型模型"><a href="#原型模型" class="headerlink" title="原型模型"></a>原型模型</h3><p>开发周期长。开发会收到需求变更的影响<br>特点:</p><ol><li>实现客户与系统的交互</li><li>进一步细化软件开发需求</li><li>开发人员可以确定客户的真正需求是什么</li></ol><h3 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h3><p>制定计划 -&gt; 风险分析 -&gt; 实施工程 -&gt; 客户评估<br>特点:</p><ol><li>螺旋模型是将瀑布模型与快速原型模型结合起来</li><li>强调了其他模型所忽视的风险分析</li><li>每一次螺旋包括4个步骤: 制定计划 -&gt; 风险分析 -&gt; 实施工程 -&gt; 客户评估</li></ol><p>缺点:<br>风险用户不太能接受</p><h3 id="敏捷模型"><a href="#敏捷模型" class="headerlink" title="敏捷模型"></a>敏捷模型</h3><p>特点: 短周期开发 增量开发<br>由程序员和测试人员编写的自动化测试来监控开发进度<br>通过口头沟通、测试先行<br>人员素质要求比较高<br>测试员掌握各种脚本语言脚本编程、能执行单元测试、自动化测试</p><h3 id="软件开发文档"><a href="#软件开发文档" class="headerlink" title="软件开发文档"></a>软件开发文档</h3><p>需求分析文档<br>概要设计文档<br>详细设计文档<br>测试计划<br>测试用例设计<br>测试报告</p><h3 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h3><p>在规定条件下对程序进行操作 已发现程序错误 衡量软件质量 评估<br>弄清预期结果与实际结果的区别</p><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>发现问题，检查系统是否满足需求</p><h3 id="软件测试的方法和分类"><a href="#软件测试的方法和分类" class="headerlink" title="软件测试的方法和分类"></a>软件测试的方法和分类</h3><h4 id="按生命周期划分"><a href="#按生命周期划分" class="headerlink" title="按生命周期划分"></a>按生命周期划分</h4><p>单元测试: 编码人员测试<br>冒烟测试: 主要流程测试<br>集成测试:<br>系统测试:<br>验收测试<br>按测试方法划分:<br>白盒测试:静态测试、动态分析: 逻辑覆盖测试、插桩测试<br>黑盒测试: 功能测试、自动化测试、性能测试、安全测试<br>灰盒测试:<br>其他:随机测试(客户、非专业人员测试)、探索性测试、阿尔法测试 β测试(验收类型测试)</p><p><img src="/image/2019-08-24-20-17-18.jpg" alt></p><h3 id="软件测试属于"><a href="#软件测试属于" class="headerlink" title="软件测试属于"></a>软件测试属于</h3><p>C/S 客户端软件/服务端软件<br>B/S 浏览器/服务器<br>测试环境 : 软件 + 硬件 + 网络<br>测试用例: 输入(数据和操作步骤) + 输出(预期结果) + 测试环境<br>冒烟测试: 在大规模测试前先进行基本的测试，看是否具有可测性<br>α测试: 内部测试<br>β测试: 最终用户测试 公测</p><h3 id="软件测试模型"><a href="#软件测试模型" class="headerlink" title="软件测试模型"></a>软件测试模型</h3><p>V模型 开发测试并行进行，编码之后<br>W模型 测试过程伴随整个开发周期，测试开发同步执行<br>H模型 测试级别之间不存在次序关系<br>X模型 分块化探索性测试，分成程序片段</p><h3 id="软件测试覆盖率"><a href="#软件测试覆盖率" class="headerlink" title="软件测试覆盖率"></a>软件测试覆盖率</h3><p>覆盖率 = (至少被执行一次的item数) / item总数</p><ol><li>通过覆盖率数据，可以检测我们的测试是否充分</li><li>分析出测试的弱点在哪里</li><li>指导增加测试用例</li></ol><p>需求覆盖: 需求点被验证<br>用例覆盖: 验证通过的用例数量 / 总的用例总数 80%</p><h3 id="软件测试的原则"><a href="#软件测试的原则" class="headerlink" title="软件测试的原则"></a>软件测试的原则</h3><ol><li>所有的测试都应该追溯到用户的需求</li><li>尽早启动测试工作</li><li>Pareto法则</li><li>穷尽测试是不可能的</li><li>杀虫剂怪事</li><li>前进两步，后退一步</li><li>三心二意 细心、信心、耐心 沟通意识、缺陷预防意识</li></ol><h3 id="软件测试规范"><a href="#软件测试规范" class="headerlink" title="软件测试规范"></a>软件测试规范</h3><ol><li>测试管理 资源管理 配置管理 测试规划 测试实施</li><li>角色的确定、进入的准则、输入项、活动过程、输出项、验证与确认、退出的准则</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型与原型链</title>
      <link href="/2019/08/11/yuan-xing-yu-yuan-xing-lian/"/>
      <url>/2019/08/11/yuan-xing-yu-yuan-xing-lian/</url>
      
        <content type="html"><![CDATA[<p>在JavaScript中， 每个实例对象都有一个私有属性，_<em>proto_</em>, 指向它的构造函数的原型对象。<br>例如</p><pre><code>var num = new Number(&quot;1&quot;)// 此时num存在一个私有属性__proto__指向Number的prototype</code></pre><p>在上例中的原型对象Number中也有自己的原型对象(__prorp__),指向Object的原型对象prototype<br>诸如此类的还有构造方法String(), Boolean(). 它们层层向上，直到一个对象的原型对象为null，null没有原型，作为原型链中的最后一个环节<br>JavaScript对象有一个指向一个原型对象的链。 当试图访问一个对象的属性时，它不仅仅在该对象上搜索，还会搜寻该对象的原型，以及对象的原型的原型，依次层层向上搜索，直到找到一个属性的名字匹配的属性或到达原型链的末尾</p><p><img src="/image/2019-08-11-16-24-13.jpg" alt><br>图中打印Number对象的结果，它包含一个__proto__私有属性，指向Number的prototype, 在下方还有一个__proto__属性，它指向Object的prototype，所以存在:</p><pre><code>var num = new Number(&quot;1&quot;)num.__proto__ === Number.prototype; \\ truenum.__proto__.__proto__ === Object.prototype; \\ trueNumber.prototype.__proto__ === Object.prototype \\ truevar obj = new Object();obj.__proto__ === Object.prototype \\ true</code></pre><p>注意:</p><ol><li>Object._<em>proto_</em> === Function.prototype  Function 是Object的构造函数</li><li>Object.prototype._<em>proto_</em> 指向null<br>总结:<br>原型链的存在使得不同的实例对象可以继承来自原型的相同的公用方法与属性。避免了重复声明与编写方法，降低了内存的占用</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>普通类型和对象的区别</title>
      <link href="/2019/08/08/pu-tong-lei-xing-he-dui-xiang-de-qu-bie/"/>
      <url>/2019/08/08/pu-tong-lei-xing-he-dui-xiang-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<blockquote><p>JS引擎将内存分为代码区和数据区，数据区分为Stack(栈)和Heap(堆) 普通类型的的数据直接存在在Stack中，而对象存放在堆中，这是普通类型和对象的重要区别</p></blockquote><h2 id="对象在内存中的存放"><a href="#对象在内存中的存放" class="headerlink" title="对象在内存中的存放"></a>对象在内存中的存放</h2><h3 id="例1"><a href="#例1" class="headerlink" title="例1:"></a>例1:</h3><pre><code>var a = {name: &#39;a&#39;}var b = ab = {name: &#39;b&#39;}a.name 是多少？</code></pre><p><img src="/image/2019-08-09-09-52-03.jpg" alt></p><p>var a = {name: ‘a’}<br>var b = a<br>此时a和b指向同一块内存</p><p><img src="/image/2019-08-09-09-55-49.jpg" alt><br> b = {name: ‘b’}<br>此时b指向的内存地址发生了变化<br>答案:b的name 为b</p><h3 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>name<span class="token punctuation">:</span> <span class="token string">'a'</span><span class="token punctuation">}</span><span class="token keyword">var</span> b <span class="token operator">=</span> ab<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'b'</span></code></pre><p><img src="/image/2019-08-09-10-01-27.jpg" alt><br>b指向的地址未发生改变，b.name 改成 ‘b’， 因为a与b指向同一块内存地址，所以a.name也为’b’</p><h3 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>name<span class="token punctuation">:</span> <span class="token string">'a'</span><span class="token punctuation">}</span><span class="token keyword">var</span> b <span class="token operator">=</span> ab <span class="token operator">=</span> <span class="token keyword">null</span></code></pre><p>a的值为？</p><p><img src="/image/2019-08-09-10-04-40.jpg" alt><br>b 的值为null, a的值为{name:’a’}</p><h3 id="例4"><a href="#例4" class="headerlink" title="例4"></a>例4</h3><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>n<span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token keyword">var</span> b <span class="token operator">=</span> aa<span class="token punctuation">.</span>x <span class="token operator">=</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>n<span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token function">alert</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>x<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// --> undefined</span><span class="token function">alert</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>x<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// --> [object Object]</span></code></pre><p>刚开始 a,b存放同一块内存地址，之后a.x 存放 a的新地址，但在对a.x赋值时，a.x仍在旧的内存块中, <strong>不能单纯的从右往左看</strong></p><p><img src="/image/2019-08-09-10-29-48.jpg" alt><br>此时，a指向新的内存地址块，但是并没有x属性，所以为undefined, b 仍指向之前的地址块， b.x 指向 a的新地址</p><h2 id="GC垃圾回收"><a href="#GC垃圾回收" class="headerlink" title="GC垃圾回收"></a>GC垃圾回收</h2><blockquote><p>如果一个对象没有被引用，它就是’垃圾’，将被回收</p></blockquote><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>name<span class="token punctuation">:</span><span class="token string">'a'</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token punctuation">{</span>name<span class="token punctuation">:</span><span class="token string">'b'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>b <span class="token operator">=</span> a<span class="token punctuation">;</span></code></pre><p>此时，{name:’b’} 没有任何被任何变量引用，它将被回收。<br>当一个标签页被关闭时，页面中的所有对象分配的内存都会被回收，当然也有例外，<strong>在ES6中，只有关闭整个浏览器，垃圾内存才会回收</strong></p><h2 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h2><p>例:</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>b <span class="token operator">=</span> a<span class="token punctuation">;</span>a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span></code></pre><p>此时b的值仍为2，没有受a值变化的影响，我们称为深拷贝，普通类型赋值就是深拷贝。<br>对象需要区分深拷贝与浅拷贝</p><pre><code>var a = {name:&#39;a&#39;};var b = {name:&#39;b&#39;};b = a;a.name = &#39;c&#39;;b.name === &#39;c&#39; \\ true</code></pre><p>此时b.name的值为’c’ , 因为对象的赋值操作是浅拷贝</p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS里的数据类型转换</title>
      <link href="/2019/08/08/js-li-de-shu-ju-lei-xing-zhuan-huan/"/>
      <url>/2019/08/08/js-li-de-shu-ju-lei-xing-zhuan-huan/</url>
      
        <content type="html"><![CDATA[<h2 id="1-任意类型转字符串"><a href="#1-任意类型转字符串" class="headerlink" title="1 任意类型转字符串"></a>1 任意类型转字符串</h2><h3 id="1-1-使用String-方法"><a href="#1-1-使用String-方法" class="headerlink" title="1.1 使用String() 方法"></a>1.1 使用String() 方法</h3><pre><code>String(1) //&quot;1&quot;String(true) //&quot;true&quot;String(null) //&quot;null&quot;String(undefined) //&quot;undefined&quot;String({}) //&quot;[object Object]&quot;</code></pre><h3 id="1-2-使用toString-方法"><a href="#1-2-使用toString-方法" class="headerlink" title="1.2 使用toString()方法"></a>1.2 使用toString()方法</h3><pre><code>(1).toString()&quot;1&quot;true.toString()&quot;true&quot;null.toString()// 无法转换 报错 : Uncaught TypeError: Cannot read property &#39;toString&#39; of nullundefined.toString()// 无法转换 报错 : Uncaught TypeError: Cannot read property &#39;toString&#39; of undefined({}).toString()&quot;[object Object]&quot;</code></pre><h3 id="1-3-使用x-‘’"><a href="#1-3-使用x-‘’" class="headerlink" title="1.3 使用x + ‘’"></a>1.3 使用x + ‘’</h3><p>结果同使用String()</p><h2 id="2-任意类型转换数字"><a href="#2-任意类型转换数字" class="headerlink" title="2 任意类型转换数字"></a>2 任意类型转换数字</h2><h3 id="2-1-使用Number"><a href="#2-1-使用Number" class="headerlink" title="2.1 使用Number()"></a>2.1 使用Number()</h3><pre><code>Number(true) // 1Number(null) // 0Number(undefined) // NaNNumber({}) // NaNNumber(&quot;1&quot;) // 1</code></pre><h3 id="2-2-使用parseInt"><a href="#2-2-使用parseInt" class="headerlink" title="2.2 使用parseInt"></a>2.2 使用parseInt</h3><p>用于将字符串转化为数字, 第一个参数为要转化的字符串，第二个参数为进制，例子中为十进制</p><pre><code>parseInt(&quot;1&quot;, 10) // 1parseInt(&quot;1a&quot;, 10) // 1parseInt(&quot;a1&quot;, 10) // NaN</code></pre><h3 id="2-3-使用parseFloat"><a href="#2-3-使用parseFloat" class="headerlink" title="2.3 使用parseFloat"></a>2.3 使用parseFloat</h3><p>用于将字符串转化为浮点数</p><h3 id="2-4-使用x-0"><a href="#2-4-使用x-0" class="headerlink" title="2.4 使用x - 0"></a>2.4 使用x - 0</h3><pre><code>&#39;18&#39; - 018true - 01false - 00</code></pre><h2 id="3-任意类型转布尔值"><a href="#3-任意类型转布尔值" class="headerlink" title="3 任意类型转布尔值"></a>3 任意类型转布尔值</h2><h3 id="3-1-使用Boolean"><a href="#3-1-使用Boolean" class="headerlink" title="3.1 使用Boolean()"></a>3.1 使用Boolean()</h3><pre><code>Boolean(1) // trueBoolean(NaN) // falseBoolean(0) // falseBoolean(&#39;&#39;) // falseBoolean(&#39;1&#39;) // trueBoolean(null) // falseBoolean(undefined) // false</code></pre><h3 id="3-2-使用-x"><a href="#3-2-使用-x" class="headerlink" title="3.2 使用!!x"></a>3.2 使用!!x</h3><pre><code>!!&#39;&#39; // false!!NaN // false</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS里的数据类型</title>
      <link href="/2019/08/05/js-li-de-shu-ju-lei-xing/"/>
      <url>/2019/08/05/js-li-de-shu-ju-lei-xing/</url>
      
        <content type="html"><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>JavaScript共有七种数据类型，分别是:</p><ul><li>数值(number)</li><li>字符串(string)</li><li>布尔值(boolean)</li><li>undefined</li><li>null</li><li>对象(object)<br>其中对象又称为合成类型，它经常由其他的基本类型组成</li></ul><h2 id="2-number类型"><a href="#2-number类型" class="headerlink" title="2. number类型"></a>2. number类型</h2><p>JavaScript内部 ，所有数字都以64位浮点数形式存储，不存在整数，所以有1 === 1.0 //true,<br>由于浮点数不是精确的值，所以涉及小数的比较和运算需要注意，如:</p><pre><code>0.1 + 0.2  // 0.30000000000000004</code></pre><h3 id="2-2-数值表示法"><a href="#2-2-数值表示法" class="headerlink" title="2.2 数值表示法"></a>2.2 数值表示法</h3><p>(1) 科学计数<br>数值可以采用科学记数法表示，如</p><pre><code>123e3 //123000123e-3 //0.123</code></pre><p>(2) 进制<br>0o表示八进制，0x表示16进制，0b表示2进制</p><pre><code>0xff // 2550o377 // 2550b11 //3</code></pre><h2 id="3-object"><a href="#3-object" class="headerlink" title="3. object"></a>3. object</h2><p>对象中的所有键名都是字符串，当键名是数值时，会被自动转为字符串.如果字符串符合标识符的定义，可以省略’’</p><pre><code>let obj = {    0:&#39;A&#39;,    1:&#39;B&#39;    }obj[0] // &#39;A&#39; </code></pre><p>当键名不符合标识符的条件时，需要加上引号 如</p><pre><code>let obj = {    &#39;1a&#39;:&#39;A&#39;,    &#39;a b&#39;:&#39;B&#39;    &#39;c+&#39;:&#39;C&#39;</code></pre><p>对象可以包含对象，设置可以包含本身</p><pre><code>let obj = {    name:&#39;zbdxsyf&#39;,    age: 18,        }</code></pre><p>对象读取属性有两种方法，一种是使用.运算符，还有一种是使用方括号</p><pre><code>let obj = {    p: &#39;Hello World&#39;    };obj.pobj[&#39;p&#39;]</code></pre><p>数字键名在方括号中加不加引号都可以，因为会自动转化为字符串,数字键名不能使用点运算符，因为有可能被当成小数<br>属性的遍历可以使用for…in循环，<br>使用for in 循环遍历对象</p><pre><code>let obj = {}for (let p in obj){    console.log(p,obj[p]) //不能使用obj.p, 因为obj.p会转化为obj[&#39;p&#39;],p是变量不是字符串    }</code></pre><p>得到obj对应的键值对<br>可以使用delete 命令来删除对象中的键值对，删除成功后返回true<br>使用delete需要注意:<br>delete删除一个不存在的属性不会报错，且返回true</p><pre><code>let obj = {}delete obj.p //true</code></pre><h2 id="5-undefined-null"><a href="#5-undefined-null" class="headerlink" title="5. undefined null"></a>5. undefined null</h2><p>null与undefined有以下区别:</p><ol><li>当变量声明未赋值时，变量的值为undefined</li><li>如果对象为空时，我们一般赋值为null 而不是undefined</li></ol><h2 id="4-typeof运算符"><a href="#4-typeof运算符" class="headerlink" title="4. typeof运算符"></a>4. typeof运算符</h2><p>使用typeof可以查看一个值的数据类型，但是存在如下问题:</p><ol><li>typeof(null) 的值为object</li><li>typeof(function)的值为function<br>事实上， null 为一种单独的数据类型，而function属于object类型</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>更换了主题</title>
      <link href="/2019/08/04/geng-huan-liao-zhu-ti/"/>
      <url>/2019/08/04/geng-huan-liao-zhu-ti/</url>
      
        <content type="html"><![CDATA[<p>选择了一个新的主题，发表文章测试一下</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>article title</title>
      <link href="/2019/08/04/article-title/"/>
      <url>/2019/08/04/article-title/</url>
      
        <content type="html"><![CDATA[<p>Hello World!</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/08/04/hello-world/"/>
      <url>/2019/08/04/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
